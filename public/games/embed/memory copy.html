<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequential Memory ‚Äì visible recall, end when all clicked</title>
    <style>
        /* ----- PASTEL THEME (unchanged) ----- */
        :root {
            --primary: #E6E6FA;
            --primary-dark: #D8BFD8;
            --secondary: #FFD700;
            --secondary-dark: #FFC107;
            --accent: #6A5ACD;
            --accent-light: #9370DB;
            --background: #F9F9FF;
            --text: #333333;
            --text-light: #666666;
            --white: #FFFFFF;
            --gray: #F0F0F0;
            --gray-dark: #E0E0E0;
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-light: rgba(0, 0, 0, 0.05);
        
            --font-heading: 'Quicksand', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-body: 'Nunito', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        
            --border-radius: 14px;
            --border-radius-lg: 24px;
            --transition: all 0.25s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            height: 100%;
        }

        body {
            font-family: var(--font-body);
            font-size: 16px;
            line-height: 1.5;
            color: var(--text);
            background: linear-gradient(145deg, var(--background) 0%, #fff 100%);
            min-height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px 80px;
        }

        .container {
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
        }

        h1, h2, h3 {
            font-family: var(--font-heading);
            font-weight: 700;
            color: var(--accent);
        }

        /* ----- TOP BLOCK (merged) ----- */
        .game-top {
            background: var(--white);
            border-radius: var(--border-radius-lg);
            padding: 30px 35px;
            margin-bottom: 30px;
            box-shadow: 0 12px 28px var(--shadow-light);
            border: 1px solid var(--primary);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }

        .title-section {
            flex: 2 1 320px;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
        }
        .game-title span { font-size: 2.4rem; }
        .game-title h1 { margin: 0; font-size: 2.2rem; }

        .tagline {
            color: var(--text-light);
            font-size: 1.05rem;
            margin-bottom: 18px;
        }

        .difficulty-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 12px 0 10px;
        }
        .difficulty-btn {
            padding: 8px 20px;
            border: 2px solid var(--accent);
            background: transparent;
            color: var(--accent);
            border-radius: 40px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
        }
        .difficulty-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .difficulty-btn:hover {
            background: var(--accent-light);
            border-color: var(--accent-light);
            color: white;
        }

        .stats-row {
            display: flex;
            flex-wrap: wrap;
            gap: 28px;
            background: var(--gray);
            padding: 14px 28px;
            border-radius: 50px;
            margin: 12px 0 5px;
        }
        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 6px;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent);
            line-height: 1;
        }
        .stat-label {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 700;
            text-transform: uppercase;
        }

        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            align-items: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 12px 26px;
            border-radius: var(--border-radius);
            font-family: var(--font-heading);
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: var(--transition);
            font-size: 1rem;
            box-shadow: 0 6px 12px var(--shadow-light);
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-light); transform: translateY(-2px); }
        .btn-secondary { background: var(--secondary); color: var(--text); }
        .btn-secondary:hover { background: var(--secondary-dark); transform: translateY(-2px); }
        .btn-accent { background: var(--primary); color: var(--text); }
        .btn-accent:hover { background: var(--primary-dark); transform: translateY(-2px); }

        /* ----- GAME ARENA ----- */
        .game-arena {
            background: var(--white);
            border-radius: var(--border-radius-lg);
            padding: 40px 30px;
            box-shadow: 0 20px 40px var(--shadow);
            border: 1px solid var(--primary-dark);
            min-height: 600px;
            display: flex;
            flex-direction: column;
        }

        /* 6‚ÄëCOLUMN UNIFORM GRID */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 16px;
            margin: 30px auto;
            width: 100%;
            max-width: 660px;
        }

        .memory-card {
            aspect-ratio: 1 / 1;
            background: var(--white);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 8px 0 rgba(0,0,0,0.02), 0 6px 12px var(--shadow-light);
            border: 2px solid var(--gray-dark);
            color: var(--text);
        }
        .memory-card.correct {
            background: var(--secondary);
            border-color: var(--secondary-dark);
        }
        .memory-card.incorrect {
            background: #FFB6C1;
            border-color: #F08080;
        }
        .memory-card.disabled {
            pointer-events: none;
            opacity: 0.9;
        }

        /* sequence display */
        .sequence-display {
            background: linear-gradient(145deg, var(--primary) 0%, var(--accent-light) 100%);
            border-radius: var(--border-radius);
            padding: 24px;
            margin: 10px 0 20px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.04);
        }
        .sequence-title {
            color: white;
            font-weight: 700;
            margin-bottom: 18px;
            font-size: 1.3rem;
            text-align: center;
        }
        .sequence-items {
            display: flex;
            justify-content: center;
            gap: 18px;
            flex-wrap: wrap;
        }
        .sequence-item {
            background: white;
            border-radius: 16px;
            width: 80px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 6px 0 rgba(0,0,0,0.03);
        }
        .item-number {
            background: var(--accent);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: bold;
            margin-bottom: 2px;
        }

        /* order display */
        .order-display {
            background: var(--gray);
            border-radius: 30px;
            padding: 20px 25px;
            border: 2px dashed var(--accent);
            margin: 20px 0;
        }
        .order-sequence {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            min-height: 52px;
        }
        .order-item {
            background: var(--white);
            border-radius: 40px;
            padding: 8px 22px;
            font-weight: 600;
            box-shadow: var(--shadow-light);
        }
        .order-item.correct { background: var(--secondary); color: var(--text); }
        .order-item.incorrect { background: #FFB6C1; }

        .progress-container {
            width: 100%;
            height: 12px;
            background: var(--gray);
            border-radius: 20px;
            margin: 15px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 20px;
            transition: width 0.3s;
        }
        .countdown-display {
            font-size: 3.2rem;
            font-weight: 800;
            color: var(--secondary-dark);
            text-align: center;
            margin: 10px 0;
        }

        /* results */
        .results-screen {
            background: var(--white);
            border-radius: var(--border-radius-lg);
            padding: 35px 25px;
            text-align: center;
        }
        .score-display {
            font-size: 4.5rem;
            font-weight: 800;
            color: var(--accent);
        }
        .result-stat {
            background: var(--primary);
            border-radius: var(--border-radius);
            padding: 18px 8px;
        }

        /* modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: 0.2s;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--white);
            border-radius: var(--border-radius-lg);
            padding: 35px;
            max-width: 550px;
            width: 90%;
            border-top: 8px solid var(--accent);
        }

        .hidden { display: none !important; }

        @media (max-width: 700px) {
            .memory-grid { gap: 10px; }
            .sequence-item { width: 65px; height: 65px; font-size: 1.8rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- BLOCK 1: HEADER + CONTROLS + STATS -->
        <div class="game-top">
            <div class="title-section">
                <div class="game-title">
                    <span>üß†</span>
                    <h1>Sequential Memory</h1>
                </div>
                <p class="tagline">6‚Äëcolumn grid ¬∑ lengths 6/8/10/12 ¬∑ end when all tiles clicked</p>
                
                <div class="difficulty-group">
                    <button class="difficulty-btn active" data-level="1">Beginner (6)</button>
                    <button class="difficulty-btn" data-level="2">Intermediate (8)</button>
                    <button class="difficulty-btn" data-level="3">Advanced (10)</button>
                    <button class="difficulty-btn" data-level="4">Expert (12)</button>
                </div>

                <div class="stats-row">
                    <div class="stat-item"><span class="stat-value" id="score">0</span><span class="stat-label">Score</span></div>
                    <div class="stat-item"><span class="stat-value" id="level">1</span><span class="stat-label">Level</span></div>
                    <div class="stat-item"><span class="stat-value" id="streak">0</span><span class="stat-label">Streak</span></div>
                    <div class="stat-item"><span class="stat-value" id="accuracy">100%</span><span class="stat-label">Acc</span></div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="startBtn">üöÄ Start Training</button>
                <button class="btn btn-secondary" id="resetBtn">üîÑ Restart</button>
                <button class="btn btn-accent" id="showInstructionsBtn">üìñ How to Play</button>
            </div>
        </div>

        <!-- BLOCK 2: GAME ARENA -->
        <div class="game-arena" id="gamePhaseContainer">
            <!-- Memorization Phase -->
            <div id="memorizePhase" class="hidden">
                <h2 style="text-align: center; color: var(--accent);">üß© Memorize the order</h2>
                <p style="text-align: center; font-size: 1.1rem;">Time left: <span id="memorizeTime">10</span>s</p>
                
                <div class="sequence-display">
                    <div class="sequence-title">üî¢ sequence with positions</div>
                    <div class="sequence-items" id="sequenceItems"></div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar" id="memorizeProgress"></div>
                </div>
                <div class="countdown-display" id="memorizeCountdown">10</div>
            </div>

            <!-- Recall Phase: shuffled grid, symbols VISIBLE -->
            <div id="recallPhase" class="hidden">
                <h2 style="text-align: center; color: var(--accent);">üîÅ Click in correct order</h2>
                <div class="order-display">
                    <div style="font-weight: 700; display: flex; gap: 8px; justify-content: center; margin-bottom: 8px;">
                        <span>üî¢</span> your sequence
                    </div>
                    <div class="order-sequence" id="orderSequence"></div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="recallProgress"></div>
                </div>
                
                <div class="memory-grid" id="recallGrid"></div>
            </div>

            <!-- Results Screen -->
            <div id="resultsScreen" class="hidden">
                <div class="results-screen">
                    <h2 style="color: var(--accent);">üéØ Round finished</h2>
                    <div class="score-display" id="finalScore">0</div>
                    <div class="performance-feedback" id="performanceFeedback" style="margin-bottom: 25px; color: var(--text-light);"></div>
                    
                    <div style="display: grid; grid-template-columns: repeat(2,1fr); gap: 20px; max-width: 500px; margin: 0 auto;">
                        <div class="result-stat"><span class="result-stat-value" id="finalTime">0s</span><div>time</div></div>
                        <div class="result-stat"><span class="result-stat-value" id="finalCorrect">0</span><div>correct</div></div>
                        <div class="result-stat"><span class="result-stat-value" id="finalSequence">0</span><div>length</div></div>
                        <div class="result-stat"><span class="result-stat-value" id="finalStreak">0</span><div>best streak</div></div>
                    </div>

                    <div style="display: flex; gap: 20px; justify-content: center; margin-top: 35px; flex-wrap: wrap;">
                        <button class="btn btn-primary" id="nextLevelBtn">‚¨ÜÔ∏è Longer</button>
                        <button class="btn btn-secondary" id="retryBtn">üîÑ Try again</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL -->
    <div class="modal-overlay" id="instructionModal">
        <div class="modal">
            <h2 class="modal-title" style="color: var(--accent); display: flex; gap: 8px;">üß† How to play</h2>
            <div class="modal-content">
                <p><strong>1.</strong> Memorise the symbols with their position numbers (#1, #2 ‚Ä¶).</p>
                <p><strong>2.</strong> After the countdown, <strong>all symbols appear shuffled</strong> ‚Äì no hiding.</p>
                <p><strong>3.</strong> Click them <strong>in the original numbered order</strong>. Each card can be clicked once.</p>
                <p><strong>4.</strong> Correct = gold, wrong = pink. <strong>The round ends immediately when every card has been clicked once.</strong></p>
                <p style="color: var(--accent); margin-top: 15px;">‚ú® 6‚Äëcolumn grid, uniform tiles. Beginner: 6, Expert: 12.</p>
            </div>
            <div class="modal-buttons" style="margin-top: 30px; display: flex; justify-content: center;">
                <button class="btn btn-primary" id="closeModalBtn">Start playing</button>
            </div>
        </div>
    </div>

    <script>
        (function(){
            // ----- CONFIG: 6/8/10/12 items, grid always 6 cols -----
            const difficultyConfig = {
                1: { items: 6, memorizeTime: 10, recallTime: 35, gridCols: 6, pointsMultiplier: 1, levelName: "Beginner" },
                2: { items: 8, memorizeTime: 13, recallTime: 40, gridCols: 6, pointsMultiplier: 1.5, levelName: "Intermediate" },
                3: { items: 10, memorizeTime: 16, recallTime: 45, gridCols: 6, pointsMultiplier: 2, levelName: "Advanced" },
                4: { items: 12, memorizeTime: 20, recallTime: 50, gridCols: 6, pointsMultiplier: 2.5, levelName: "Expert" }
            };

            const symbols = ['‚≠ê', '‚ù§Ô∏è', 'üî∂', 'üî∑', '‚ö°', 'üåà', 'üéØ', 'üé®', 'üéµ', 'üî¢',
                            'üîî', 'üîë', 'üíé', 'üé©', 'üèÜ', 'üöÄ', 'üé≠', '‚öΩ', 'üé∏', 'üçé',
                            'üçï', 'üè†', 'üåô', '‚òÄÔ∏è', '‚òÅÔ∏è', '‚ùÑÔ∏è', 'üî•', 'üíß', 'üå≥', 'üå∏'];

            // ----- GAME STATE -----
            const gameState = {
                difficulty: 1,
                score: 0,
                streak: 0,
                bestStreak: 0,
                correctCount: 0,
                totalAttempts: 0,
                itemsToMemorize: [],
                userSequence: [],      // stores original indices of CORRECT clicks in order
                gameActive: false,
                currentPhase: null,
                startTime: null,
                timerInterval: null,
                clickedCards: new Set() // track which positions have been clicked (once)
            };

            // ----- DOM elements -----
            const elements = {
                memorizePhase: document.getElementById('memorizePhase'),
                recallPhase: document.getElementById('recallPhase'),
                resultsScreen: document.getElementById('resultsScreen'),
                recallGrid: document.getElementById('recallGrid'),
                sequenceItems: document.getElementById('sequenceItems'),
                orderSequence: document.getElementById('orderSequence'),
                score: document.getElementById('score'),
                level: document.getElementById('level'),
                streak: document.getElementById('streak'),
                accuracy: document.getElementById('accuracy'),
                finalScore: document.getElementById('finalScore'),
                finalTime: document.getElementById('finalTime'),
                finalCorrect: document.getElementById('finalCorrect'),
                finalSequence: document.getElementById('finalSequence'),
                finalStreak: document.getElementById('finalStreak'),
                performanceFeedback: document.getElementById('performanceFeedback'),
                memorizeCountdown: document.getElementById('memorizeCountdown'),
                memorizeProgress: document.getElementById('memorizeProgress'),
                recallProgress: document.getElementById('recallProgress'),
                memorizeTime: document.getElementById('memorizeTime'),
                startBtn: document.getElementById('startBtn'),
                resetBtn: document.getElementById('resetBtn'),
                showInstructionsBtn: document.getElementById('showInstructionsBtn'),
                nextLevelBtn: document.getElementById('nextLevelBtn'),
                retryBtn: document.getElementById('retryBtn'),
                instructionModal: document.getElementById('instructionModal'),
                closeModalBtn: document.getElementById('closeModalBtn'),
                difficultyBtns: document.querySelectorAll('.difficulty-btn')
            };

            // ----- helpers -----
            function hideAllPhases() {
                elements.memorizePhase.classList.add('hidden');
                elements.recallPhase.classList.add('hidden');
                elements.resultsScreen.classList.add('hidden');
            }

            function generateItems() {
                const config = difficultyConfig[gameState.difficulty];
                const count = config.items;
                gameState.itemsToMemorize = [];
                const shuffledPool = [...symbols].sort(() => Math.random() - 0.5).slice(0, count);
                for (let i = 0; i < count; i++) {
                    gameState.itemsToMemorize.push({
                        id: i + 1,
                        symbol: shuffledPool[i],
                        position: i
                    });
                }
            }

            function updateStats() {
                elements.score.textContent = gameState.score;
                elements.level.textContent = gameState.difficulty;
                elements.streak.textContent = gameState.streak;
                const acc = gameState.totalAttempts > 0 ? Math.round((gameState.correctCount / gameState.totalAttempts) * 100) : 100;
                elements.accuracy.textContent = acc + '%';
            }

            // ----- GAME FLOW -----
            function startGame() {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);

                gameState.gameActive = true;
                gameState.currentPhase = 'memorize';
                gameState.userSequence = [];
                gameState.clickedCards.clear();
                gameState.correctCount = 0;
                gameState.totalAttempts = 0;
                gameState.streak = 0;
                gameState.startTime = Date.now();

                generateItems();
                hideAllPhases();
                elements.memorizePhase.classList.remove('hidden');

                // fill sequence display
                elements.sequenceItems.innerHTML = '';
                gameState.itemsToMemorize.forEach(item => {
                    const box = document.createElement('div');
                    box.className = 'sequence-item';
                    box.innerHTML = `<div class="item-number">${item.id}</div>${item.symbol}`;
                    elements.sequenceItems.appendChild(box);
                });

                // start memorization countdown
                const config = difficultyConfig[gameState.difficulty];
                let timeLeft = config.memorizeTime;
                elements.memorizeTime.textContent = config.memorizeTime;
                elements.memorizeCountdown.textContent = timeLeft;
                elements.memorizeProgress.style.width = '0%';

                gameState.timerInterval = setInterval(() => {
                    timeLeft--;
                    elements.memorizeCountdown.textContent = timeLeft;
                    const percent = ((config.memorizeTime - timeLeft) / config.memorizeTime) * 100;
                    elements.memorizeProgress.style.width = percent + '%';
                    if (timeLeft <= 0) {
                        clearInterval(gameState.timerInterval);
                        startRecallPhase();
                    }
                }, 1000);

                updateStats();
            }

            function startRecallPhase() {
                gameState.currentPhase = 'recall';
                hideAllPhases();
                elements.recallPhase.classList.remove('hidden');
                elements.orderSequence.innerHTML = '';

                const config = difficultyConfig[gameState.difficulty];
                // build recall grid: 6 columns, shuffled, symbols VISIBLE
                elements.recallGrid.innerHTML = '';
                const indices = [...Array(config.items).keys()];
                const shuffledIdx = indices.sort(() => Math.random() - 0.5);
                
                shuffledIdx.forEach(origPos => {
                    const item = gameState.itemsToMemorize[origPos];
                    const card = document.createElement('div');
                    card.className = 'memory-card';
                    card.dataset.id = item.id;
                    card.dataset.symbol = item.symbol;
                    card.dataset.position = origPos;
                    card.textContent = item.symbol;
                    card.addEventListener('click', (e) => handleCardClick(origPos, card));
                    elements.recallGrid.appendChild(card);
                });

                // recall timer
                let timeLeft = config.recallTime;
                elements.recallProgress.style.width = '0%';
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                gameState.timerInterval = setInterval(() => {
                    timeLeft--;
                    const percent = ((config.recallTime - timeLeft) / config.recallTime) * 100;
                    elements.recallProgress.style.width = percent + '%';
                    // End if timer runs out OR all cards have been clicked
                    if (timeLeft <= 0 || gameState.clickedCards.size === config.items) {
                        clearInterval(gameState.timerInterval);
                        endRound();
                    }
                }, 1000);
            }

            function handleCardClick(originalPosition, cardEl) {
                if (gameState.currentPhase !== 'recall') return;
                // already clicked this card? -> ignore
                if (gameState.clickedCards.has(originalPosition)) return;
                
                const clickedItem = gameState.itemsToMemorize[originalPosition];
                const expectedIndex = gameState.userSequence.length;
                const expectedItem = gameState.itemsToMemorize[expectedIndex];
                const isCorrect = (clickedItem.id === expectedItem.id);

                gameState.totalAttempts++;
                gameState.clickedCards.add(originalPosition);
                cardEl.classList.add('disabled'); // prevent second click

                if (isCorrect) {
                    cardEl.classList.add('correct');
                    gameState.userSequence.push(originalPosition);
                    gameState.correctCount++;
                    gameState.streak++;
                    if (gameState.streak > gameState.bestStreak) gameState.bestStreak = gameState.streak;

                    // points
                    const base = 10;
                    const streakBonus = Math.min(gameState.streak, 5) * 2;
                    const diffBonus = (gameState.difficulty - 1) * 5;
                    gameState.score += base + streakBonus + diffBonus;

                    // add to order display
                    const orderDiv = document.createElement('div');
                    orderDiv.className = 'order-item correct';
                    orderDiv.textContent = `${clickedItem.id}: ${clickedItem.symbol}`;
                    elements.orderSequence.appendChild(orderDiv);
                    elements.orderSequence.scrollLeft = elements.orderSequence.scrollWidth;

                    // completion bonus if the whole sequence is correct
                    if (gameState.userSequence.length === difficultyConfig[gameState.difficulty].items) {
                        gameState.score += difficultyConfig[gameState.difficulty].items * 5;
                    }
                } else {
                    cardEl.classList.add('incorrect');
                    gameState.streak = 0;
                    const orderDiv = document.createElement('div');
                    orderDiv.className = 'order-item incorrect';
                    orderDiv.textContent = `${clickedItem.id}: ${clickedItem.symbol}`;
                    elements.orderSequence.appendChild(orderDiv);
                    // remove wrong indicator after 1.2s
                    setTimeout(() => { if (orderDiv.parentNode) orderDiv.remove(); }, 1200);
                }

                updateStats();

                // NEW: If all cards have now been clicked, end the round immediately
                const totalItems = difficultyConfig[gameState.difficulty].items;
                if (gameState.clickedCards.size === totalItems) {
                    // Clear timer and end round
                    if (gameState.timerInterval) {
                        clearInterval(gameState.timerInterval);
                        gameState.timerInterval = null;
                    }
                    // Small delay to let the last card's colour appear
                    setTimeout(() => {
                        if (gameState.currentPhase === 'recall') {
                            endRound();
                        }
                    }, 200);
                }
            }

            function endRound() {
                gameState.gameActive = false;
                gameState.currentPhase = 'results';
                const timeUsed = Math.round((Date.now() - gameState.startTime) / 1000);
                hideAllPhases();
                elements.resultsScreen.classList.remove('hidden');

                elements.finalScore.textContent = gameState.score;
                elements.finalTime.textContent = timeUsed + 's';
                elements.finalCorrect.textContent = gameState.correctCount;
                elements.finalSequence.textContent = difficultyConfig[gameState.difficulty].items;
                elements.finalStreak.textContent = gameState.bestStreak;
                const accuracy = gameState.totalAttempts ? Math.round((gameState.correctCount / gameState.totalAttempts) * 100) : 100;
                let feedback = '';
                if (gameState.correctCount === difficultyConfig[gameState.difficulty].items) {
                    feedback = 'Perfect sequence! Excellent memory.';
                } else {
                    feedback = `You clicked all tiles. Accuracy: ${accuracy}% ‚Äì keep training.`;
                }
                elements.performanceFeedback.textContent = feedback;
            }

            function resetGame(keepDifficulty = true) {
                if (!keepDifficulty) {
                    gameState.difficulty = 1;
                    elements.difficultyBtns.forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.level == 1) btn.classList.add('active');
                    });
                }
                gameState.score = 0;
                gameState.streak = 0;
                gameState.bestStreak = 0;
                gameState.correctCount = 0;
                gameState.totalAttempts = 0;
                gameState.userSequence = [];
                gameState.clickedCards.clear();
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                hideAllPhases();
                updateStats();
            }

            // ----- EVENT LISTENERS -----
            elements.startBtn.addEventListener('click', startGame);
            elements.resetBtn.addEventListener('click', () => resetGame(true));
            elements.showInstructionsBtn.addEventListener('click', () => {
                elements.instructionModal.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
            elements.closeModalBtn.addEventListener('click', () => {
                elements.instructionModal.classList.remove('active');
                document.body.style.overflow = '';
            });
            elements.instructionModal.addEventListener('click', (e) => {
                if (e.target === elements.instructionModal) {
                    elements.instructionModal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });

            elements.nextLevelBtn.addEventListener('click', () => {
                if (gameState.difficulty < 4) gameState.difficulty++;
                else { gameState.difficulty = 1; gameState.score = 0; }
                elements.difficultyBtns.forEach(btn => {
                    btn.classList.remove('active');
                    if (parseInt(btn.dataset.level) === gameState.difficulty) btn.classList.add('active');
                });
                startGame();
            });

            elements.retryBtn.addEventListener('click', startGame);

            elements.difficultyBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    elements.difficultyBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    gameState.difficulty = parseInt(this.dataset.level);
                    resetGame(true);
                });
            });

            // initial reset & first‚Äëvisit modal
            resetGame(true);
            if (!localStorage.getItem('memoryGameVisited')) {
                setTimeout(() => {
                    elements.instructionModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    localStorage.setItem('memoryGameVisited', 'true');
                }, 400);
            }
        })();
    </script>
</body>
</html>